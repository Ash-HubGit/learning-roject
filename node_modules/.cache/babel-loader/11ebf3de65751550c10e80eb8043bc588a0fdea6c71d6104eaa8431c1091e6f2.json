{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.checkMaskIsValidForCurrentFormat = checkMaskIsValidForCurrentFormat;\nexports.getDisplayDate = void 0;\nexports.getMaskFromCurrentFormat = getMaskFromCurrentFormat;\nexports.maskedDateFormatter = void 0;\nconst getDisplayDate = (utils, rawValue, inputFormat) => {\n  const date = utils.date(rawValue);\n  const isEmpty = rawValue === null;\n  if (isEmpty) {\n    return '';\n  }\n  return utils.isValid(date) ? utils.formatByString(\n  // TODO: should `isValid` narrow `TDate | null` to `NonNullable<TDate>`?\n  // Either we allow `TDate | null` to be valid and guard against calling `formatByString` with `null`.\n  // Or we ensure `formatByString` is callable with `null`.\n  date, inputFormat) : '';\n};\nexports.getDisplayDate = getDisplayDate;\nconst MASK_USER_INPUT_SYMBOL = '_';\nconst staticDateWith2DigitTokens = '2019-11-21T22:30:00.000';\nconst staticDateWith1DigitTokens = '2019-01-01T09:00:00.000';\nfunction getMaskFromCurrentFormat(mask, format, acceptRegex, utils) {\n  if (mask) {\n    return mask;\n  }\n  const formattedDateWith1Digit = utils.formatByString(utils.date(staticDateWith1DigitTokens), format);\n  const inferredFormatPatternWith1Digits = formattedDateWith1Digit.replace(acceptRegex, MASK_USER_INPUT_SYMBOL);\n  const inferredFormatPatternWith2Digits = utils.formatByString(utils.date(staticDateWith2DigitTokens), format).replace(acceptRegex, '_');\n  if (inferredFormatPatternWith1Digits === inferredFormatPatternWith2Digits) {\n    return inferredFormatPatternWith1Digits;\n  }\n  if (process.env.NODE_ENV !== 'production') {\n    console.warn([`Mask does not support numbers with variable length such as 'M'.`, `Either use numbers with fix length or disable mask feature with 'disableMaskedInput' prop`, `Falling down to uncontrolled no-mask input.`].join('\\n'));\n  }\n  return '';\n}\nfunction checkMaskIsValidForCurrentFormat(mask, format, acceptRegex, utils) {\n  if (!mask) {\n    return false;\n  }\n  const formattedDateWith1Digit = utils.formatByString(utils.date(staticDateWith1DigitTokens), format);\n  const inferredFormatPatternWith1Digits = formattedDateWith1Digit.replace(acceptRegex, MASK_USER_INPUT_SYMBOL);\n  const inferredFormatPatternWith2Digits = utils.formatByString(utils.date(staticDateWith2DigitTokens), format).replace(acceptRegex, '_');\n  const isMaskValid = inferredFormatPatternWith2Digits === inferredFormatPatternWith1Digits && mask === inferredFormatPatternWith2Digits;\n  if (!isMaskValid && utils.lib !== 'luxon' && process.env.NODE_ENV !== 'production') {\n    if (format.includes('MMM')) {\n      console.warn([`Mask does not support literals such as 'MMM'.`, `Either use numbers with fix length or disable mask feature with 'disableMaskedInput' prop`, `Falling down to uncontrolled no-mask input.`].join('\\n'));\n    } else if (inferredFormatPatternWith2Digits && inferredFormatPatternWith2Digits !== inferredFormatPatternWith1Digits) {\n      console.warn([`Mask does not support numbers with variable length such as 'M'.`, `Either use numbers with fix length or disable mask feature with 'disableMaskedInput' prop`, `Falling down to uncontrolled no-mask input.`].join('\\n'));\n    } else if (mask) {\n      console.warn([`The mask \"${mask}\" you passed is not valid for the format used ${format}.`, `Falling down to uncontrolled no-mask input.`].join('\\n'));\n    }\n  }\n  return isMaskValid;\n}\nconst maskedDateFormatter = (mask, acceptRegexp) => value => {\n  let outputCharIndex = 0;\n  return value.split('').map((char, inputCharIndex) => {\n    acceptRegexp.lastIndex = 0;\n    if (outputCharIndex > mask.length - 1) {\n      return '';\n    }\n    const maskChar = mask[outputCharIndex];\n    const nextMaskChar = mask[outputCharIndex + 1];\n    const acceptedChar = acceptRegexp.test(char) ? char : '';\n    const formattedChar = maskChar === MASK_USER_INPUT_SYMBOL ? acceptedChar : maskChar + acceptedChar;\n    outputCharIndex += formattedChar.length;\n    const isLastCharacter = inputCharIndex === value.length - 1;\n    if (isLastCharacter && nextMaskChar && nextMaskChar !== MASK_USER_INPUT_SYMBOL) {\n      // when cursor at the end of mask part (e.g. month) prerender next symbol \"21\" -> \"21/\"\n      return formattedChar ? formattedChar + nextMaskChar : '';\n    }\n    return formattedChar;\n  }).join('');\n};\nexports.maskedDateFormatter = maskedDateFormatter;","map":{"version":3,"names":["Object","defineProperty","exports","value","checkMaskIsValidForCurrentFormat","getDisplayDate","getMaskFromCurrentFormat","maskedDateFormatter","utils","rawValue","inputFormat","date","isEmpty","isValid","formatByString","MASK_USER_INPUT_SYMBOL","staticDateWith2DigitTokens","staticDateWith1DigitTokens","mask","format","acceptRegex","formattedDateWith1Digit","inferredFormatPatternWith1Digits","replace","inferredFormatPatternWith2Digits","process","env","NODE_ENV","console","warn","join","isMaskValid","lib","includes","acceptRegexp","outputCharIndex","split","map","char","inputCharIndex","lastIndex","length","maskChar","nextMaskChar","acceptedChar","test","formattedChar","isLastCharacter"],"sources":["/Users/ashyr/Desktop/Devs/React/reilly-course/projec-goal-app/node_modules/@mui/x-date-pickers/node/internals/utils/text-field-helper.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.checkMaskIsValidForCurrentFormat = checkMaskIsValidForCurrentFormat;\nexports.getDisplayDate = void 0;\nexports.getMaskFromCurrentFormat = getMaskFromCurrentFormat;\nexports.maskedDateFormatter = void 0;\n\nconst getDisplayDate = (utils, rawValue, inputFormat) => {\n  const date = utils.date(rawValue);\n  const isEmpty = rawValue === null;\n\n  if (isEmpty) {\n    return '';\n  }\n\n  return utils.isValid(date) ? utils.formatByString( // TODO: should `isValid` narrow `TDate | null` to `NonNullable<TDate>`?\n  // Either we allow `TDate | null` to be valid and guard against calling `formatByString` with `null`.\n  // Or we ensure `formatByString` is callable with `null`.\n  date, inputFormat) : '';\n};\n\nexports.getDisplayDate = getDisplayDate;\nconst MASK_USER_INPUT_SYMBOL = '_';\nconst staticDateWith2DigitTokens = '2019-11-21T22:30:00.000';\nconst staticDateWith1DigitTokens = '2019-01-01T09:00:00.000';\n\nfunction getMaskFromCurrentFormat(mask, format, acceptRegex, utils) {\n  if (mask) {\n    return mask;\n  }\n\n  const formattedDateWith1Digit = utils.formatByString(utils.date(staticDateWith1DigitTokens), format);\n  const inferredFormatPatternWith1Digits = formattedDateWith1Digit.replace(acceptRegex, MASK_USER_INPUT_SYMBOL);\n  const inferredFormatPatternWith2Digits = utils.formatByString(utils.date(staticDateWith2DigitTokens), format).replace(acceptRegex, '_');\n\n  if (inferredFormatPatternWith1Digits === inferredFormatPatternWith2Digits) {\n    return inferredFormatPatternWith1Digits;\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    console.warn([`Mask does not support numbers with variable length such as 'M'.`, `Either use numbers with fix length or disable mask feature with 'disableMaskedInput' prop`, `Falling down to uncontrolled no-mask input.`].join('\\n'));\n  }\n\n  return '';\n}\n\nfunction checkMaskIsValidForCurrentFormat(mask, format, acceptRegex, utils) {\n  if (!mask) {\n    return false;\n  }\n\n  const formattedDateWith1Digit = utils.formatByString(utils.date(staticDateWith1DigitTokens), format);\n  const inferredFormatPatternWith1Digits = formattedDateWith1Digit.replace(acceptRegex, MASK_USER_INPUT_SYMBOL);\n  const inferredFormatPatternWith2Digits = utils.formatByString(utils.date(staticDateWith2DigitTokens), format).replace(acceptRegex, '_');\n  const isMaskValid = inferredFormatPatternWith2Digits === inferredFormatPatternWith1Digits && mask === inferredFormatPatternWith2Digits;\n\n  if (!isMaskValid && utils.lib !== 'luxon' && process.env.NODE_ENV !== 'production') {\n    if (format.includes('MMM')) {\n      console.warn([`Mask does not support literals such as 'MMM'.`, `Either use numbers with fix length or disable mask feature with 'disableMaskedInput' prop`, `Falling down to uncontrolled no-mask input.`].join('\\n'));\n    } else if (inferredFormatPatternWith2Digits && inferredFormatPatternWith2Digits !== inferredFormatPatternWith1Digits) {\n      console.warn([`Mask does not support numbers with variable length such as 'M'.`, `Either use numbers with fix length or disable mask feature with 'disableMaskedInput' prop`, `Falling down to uncontrolled no-mask input.`].join('\\n'));\n    } else if (mask) {\n      console.warn([`The mask \"${mask}\" you passed is not valid for the format used ${format}.`, `Falling down to uncontrolled no-mask input.`].join('\\n'));\n    }\n  }\n\n  return isMaskValid;\n}\n\nconst maskedDateFormatter = (mask, acceptRegexp) => value => {\n  let outputCharIndex = 0;\n  return value.split('').map((char, inputCharIndex) => {\n    acceptRegexp.lastIndex = 0;\n\n    if (outputCharIndex > mask.length - 1) {\n      return '';\n    }\n\n    const maskChar = mask[outputCharIndex];\n    const nextMaskChar = mask[outputCharIndex + 1];\n    const acceptedChar = acceptRegexp.test(char) ? char : '';\n    const formattedChar = maskChar === MASK_USER_INPUT_SYMBOL ? acceptedChar : maskChar + acceptedChar;\n    outputCharIndex += formattedChar.length;\n    const isLastCharacter = inputCharIndex === value.length - 1;\n\n    if (isLastCharacter && nextMaskChar && nextMaskChar !== MASK_USER_INPUT_SYMBOL) {\n      // when cursor at the end of mask part (e.g. month) prerender next symbol \"21\" -> \"21/\"\n      return formattedChar ? formattedChar + nextMaskChar : '';\n    }\n\n    return formattedChar;\n  }).join('');\n};\n\nexports.maskedDateFormatter = maskedDateFormatter;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}